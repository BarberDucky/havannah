;;Helper functions**********************************************************************************************************************
(defun isCorner (i j) 
  (cond ( (and (equalp i '0) (equalp j '0)) '1)
        ( (and (equalp i '0) (equalp j (- *n* 1)) ) '1)
        ( (and (equalp i (- *n* 1)) (equalp j '0) ) '1)
        ( (and (equalp i (- *n* 1)) (equalp j (- *matrixDim* 1)) ) '1)
        ( (and (equalp i (- *matrixDim* 1)) (equalp j (- *n* 1)) ) '1)
        ( (and (equalp i (- *matrixDim* 1)) (equalp j (- *matrixDim* 1)) ) '1)
        ( t '0) 
        ))

(defun isEdge (i j)
  (cond ( (not (equalp (isCorner i j) '0)) '0 )
        ( (equalp i '0) '1 )
        ( (equalp i (- *matrixDim* 1)) '2 )
        ( (and (< i *n*) (equalp j '0) ) '4 )
        ( (and (< i *n*) (equalp j (- *n* 1 (- '0 i))) ) '8 )
        ( (and (>= i *n*) (equalp j (- *matrixDim* 1)) ) '16 )
        ( (and (>= i *n*) (equalp j (- i *n* -1)) ) '32 )
        ( t '0 )
        ))

(defun parentIndex(i j dim)
  (+ j (* i dim)))

(defun getColumnFromIndex(index dim)
  (mod index dim))

(defun getRowFromIndex(index column dim)
  (/ (- index column) dim))  

(defun findNeighbours (board i j currentPlayer)
  (let ((neighbourList '()))
    (progn 
      (if (and (>= (- i 1) 0) (>= (- j 1) 0) (not (equalp 0 (aref board (- i 1) (- j 1)))) (equalp (cell-value (aref board (- i 1) (- j 1))) currentPlayer)) 
           (setq neighbourList (append neighbourList (list (parentIndex (- i 1) (- j 1) *matrixDim* )))))
      (if (and (>= (- i 1) 0) (not (equalp 0 (aref board (- i 1) j))) (equalp (cell-value (aref board (- i 1) j)) currentPlayer)) 
          (setq neighbourList (append neighbourList (list (parentIndex (- i 1) j *matrixDim*)))))
      (if (and (>= (- j 1) 0) (not (equalp 0 (aref board i (- j 1)))) (equalp (cell-value (aref board i (- j 1))) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex i (- j 1) *matrixDim*)))))
      (if (and (< (+ j 1) *matrixDim*) (not (equalp 0 (aref board i (+ j 1)))) (equalp (cell-value (aref board i (+ j 1))) currentPlayer))
           (setq neighbourList (append neighbourList (list (parentIndex i (+ j 1) *matrixDim*)))))
      (if (and (< (+ i 1) *matrixDim*) (not (equalp 0 (aref board (+ i 1) j))) (equalp (cell-value (aref board (+ i 1) j)) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex (+ i 1) j *matrixDim*)))))
      (if (and (< (+ i 1) *matrixDim*) (< (+ j 1) *matrixDim*) (not (equalp 0 (aref board (+ i 1) (+ j 1)))) (< (+ j 1) *matrixDim*) (equalp (cell-value (aref board (+ i 1) (+ j 1))) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex (+ i 1) (+ j 1) *matrixDim*)))))
      )
    (return-from findNeighbours neighbourList)
    ))

(defun findNeighboursNew (board row col currentPlayer)
  (let* ((neighbourList '()) (nextNb '()))
    (dotimes (i '6)
      (setf nextNb (validateNeighbourIndex row col i currentPlayer board))
      (if (not (null nextNb))
         (setf neighbourList (append neighbourList (list (parentIndex (car nextNb) (cadr nextNb) *matrixDim*))))))
    (return-from findNeighboursNew neighbourList)))

(defun validateNeighbourIndex(row col indexNb currentPlayer board)
  (let* ((neighbour (aref *neighbours* indexNb))
         (rowNb (+ row (car neighbour)))
         (colNb (+ col (cadr neighbour))))
    (cond ((or (< rowNb '0) (< colNb '0) (>= rowNb *matrixDim*) (>= colNb *matrixDim*)) '())
          (t (let ((matrixElement (aref board rowNb colNb)))
               (cond ((equalp matrixElement *invalidField*) '())
                     ((equalp (cell-value matrixElement) currentPlayer) (list rowNb colNb (caddr neighbour) ))
                     (t( return-from validateNeighbourIndex '() ))))))))

;;**************************** LOCALITY HELPERS *********************************************************************

(defun validateNeighbourSecond (row col indexNb board)
   (let* ((neighbour (aref *neighbours* indexNb))
         (rowNb (+ row (car neighbour)))
         (colNb (+ col (cadr neighbour))))
    (cond ((or (< rowNb '0) (< colNb '0) (>= rowNb *matrixDim*) (>= colNb *matrixDim*)) '())
          (t (let ((matrixElement (aref board rowNb colNb)))
               (cond ((equalp matrixElement *invalidField*) '())
                     (t (return-from validateNeighbourSecond (list rowNb colNb (caddr neighbour) )))))))))

(defun findNeighboursSecond (board row col)
  (let* ((neighbourList '()) (nextNb '()))
    (dotimes (i '18)
      (setf nextNb (validateNeighbourSecond row col i board))
      (if (not (null nextNb))
          (setf neighbourList (append neighbourList (list nextNb)))))
    (return-from findNeighboursSecond neighbourList)))

;; firstPlayer shift - '0; secondPlayer - '2
(defun setLocality (board row col currentPlayer)
  (let* ((neighbourList '())
         (shifte '0))
    (setf neighbourList (findNeighboursSecond board row col))
    (if (equalp currentPlayer *secondPlayer*) (setf shifte '2))
    (dolist (el neighbourList)
      (let* ((score (caddr el))
             (matrixEl (aref board (car el) (cadr el)))
             (newScore '0))
        (setf newScore (ash score shifte))
        (setf (cell-locality matrixEl) 
          (list (logior (car (cell-locality matrixEl)) newScore)))
        ))))

;;********************************************* LOCALITY COMPUTER FUNCTIONS **********************************************************

(defun setLocalityComputer (board row col currentPlayer)
  (let* ((neighbourList '())
         (shifte '0))
    (setf neighbourList (findNeighboursSecond board row col))
    (if (equalp currentPlayer *secondPlayer*) (setf shifte '2))
    (dolist (el neighbourList)
      (let* ((score (caddr el))
             (matrixEl (aref board (car el) (cadr el)))
             (newScore '0))
        (setf newScore (ash score shifte))
        (setf (cell-locality matrixEl) 
          (append (list (logior (car (cell-locality matrixEl)) newScore)) (cell-locality matrixEl))
          )))))

(defun unsetLocalityComputer (board row col)
  (let* ((neighbourList '()))
    (setf neighbourList (findNeighboursSecond board row col))
    (dolist (el neighbourList)
      (let* ((matrixEl (aref board (car el) (cadr el))))
        (if (not (null (cdr (cell-locality matrixEl)))) 
            (setf (cell-locality matrixEl) (cdr(cell-locality matrixEl))))))))

      

