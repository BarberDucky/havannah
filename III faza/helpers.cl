;;Helper functions**********************************************************************************************************************
(defun isCorner (i j) 
  (cond ( (and (equalp i '0) (equalp j '0)) '1)
        ( (and (equalp i '0) (equalp j (- *n* 1)) ) '1)
        ( (and (equalp i (- *n* 1)) (equalp j '0) ) '1)
        ( (and (equalp i (- *n* 1)) (equalp j (- *matrixDim* 1)) ) '1)
        ( (and (equalp i (- *matrixDim* 1)) (equalp j (- *n* 1)) ) '1)
        ( (and (equalp i (- *matrixDim* 1)) (equalp j (- *matrixDim* 1)) ) '1)
        ( t '0) 
        ))

(defun isEdge (i j)
  (cond ( (not (equalp (isCorner i j) '0)) '0 )
        ( (equalp i '0) '1 )
        ( (equalp i (- *matrixDim* 1)) '2 )
        ( (and (< i *n*) (equalp j '0) ) '4 )
        ( (and (< i *n*) (equalp j (- *n* 1 (- '0 i))) ) '8 )
        ( (and (>= i *n*) (equalp j (- *matrixDim* 1)) ) '16 )
        ( (and (>= i *n*) (equalp j (- i *n* -1)) ) '32 )
        ( t '0 )
        ))

(defun parentIndex(i j dim)
  (+ j (* i dim)))

(defun getColumnFromIndex(index dim)
  (mod index dim))

(defun getRowFromIndex(index column dim)
  (/ (- index column) dim))  

(defun findNeighbours (board i j currentPlayer)
  (let ((neighbourList '()))
    (progn 
      (if (and (>= (- i 1) 0) (>= (- j 1) 0) (not (equalp 0 (aref board (- i 1) (- j 1)))) (equalp (cell-value (aref board (- i 1) (- j 1))) currentPlayer)) 
           (setq neighbourList (append neighbourList (list (parentIndex (- i 1) (- j 1) *matrixDim* )))))
      (if (and (>= (- i 1) 0) (not (equalp 0 (aref board (- i 1) j))) (equalp (cell-value (aref board (- i 1) j)) currentPlayer)) 
          (setq neighbourList (append neighbourList (list (parentIndex (- i 1) j *matrixDim*)))))
      (if (and (>= (- j 1) 0) (not (equalp 0 (aref board i (- j 1)))) (equalp (cell-value (aref board i (- j 1))) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex i (- j 1) *matrixDim*)))))
      (if (and (< (+ j 1) *matrixDim*) (not (equalp 0 (aref board i (+ j 1)))) (equalp (cell-value (aref board i (+ j 1))) currentPlayer))
           (setq neighbourList (append neighbourList (list (parentIndex i (+ j 1) *matrixDim*)))))
      (if (and (< (+ i 1) *matrixDim*) (not (equalp 0 (aref board (+ i 1) j))) (equalp (cell-value (aref board (+ i 1) j)) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex (+ i 1) j *matrixDim*)))))
      (if (and (< (+ i 1) *matrixDim*) (< (+ j 1) *matrixDim*) (not (equalp 0 (aref board (+ i 1) (+ j 1)))) (< (+ j 1) *matrixDim*) (equalp (cell-value (aref board (+ i 1) (+ j 1))) currentPlayer))
          (setq neighbourList (append neighbourList (list (parentIndex (+ i 1) (+ j 1) *matrixDim*)))))
      )
    (return-from findNeighbours neighbourList)
    ))

(defun findNeighboursNew (board row col currentPlayer)
  (let* ((neighbourList '()) (nextNb '()))
    (dotimes (i '6)
      (setf nextNb (validateNeighbourIndex row col i currentPlayer board))
      (if (not (null nextNb))
         (setf neighbourList (append neighbourList (list (parentIndex (car nextNb) (cadr nextNb) *matrixDim*))))))
    (return-from findNeighboursNew neighbourList)))

(defun validateNeighbourIndex(row col indexNb currentPlayer board)
  (let* ((neighbour (aref *neighbours* indexNb))
         (rowNb (+ row (car neighbour)))
         (colNb (+ col (cadr neighbour))))
    (cond ((or (< rowNb '0) (< colNb '0) (>= rowNb *matrixDim*) (>= colNb *matrixDim*)) '())
          (t (let ((matrixElement (aref board rowNb colNb)))
               (cond ((equalp matrixElement *invalidField*) '())
                     ((equalp (cell-value matrixElement) currentPlayer) (list rowNb colNb))
                     (t( return-from validateNeighbourIndex '() ))))))))
  